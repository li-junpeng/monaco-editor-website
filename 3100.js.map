{"version":3,"file":"3100.js","mappings":"8IAAA,o1S","sources":["file:///C:\\0-E\\Code Store\\monaco-editor\\website\\src\\website\\data\\home-samples\\sample.cpp.txt"],"sourcesContent":["export default \"#include \\\"pch.h\\\"\\r\\n#include \\\"Direct3DBase.h\\\"\\r\\n\\r\\nusing namespace Microsoft::WRL;\\r\\nusing namespace Windows::UI::Core;\\r\\nusing namespace Windows::Foundation;\\r\\n\\r\\n// Constructor.\\r\\nDirect3DBase::Direct3DBase()\\r\\n{\\r\\n}\\r\\n\\r\\n// Initialize the Direct3D resources required to run.\\r\\nvoid Direct3DBase::Initialize(CoreWindow^ window)\\r\\n{\\r\\n    m_window = window;\\r\\n    \\r\\n    CreateDeviceResources();\\r\\n    CreateWindowSizeDependentResources();\\r\\n}\\r\\n\\r\\n// These are the resources that depend on the device.\\r\\nvoid Direct3DBase::CreateDeviceResources()\\r\\n{\\r\\n    // This flag adds support for surfaces with a different color channel ordering than the API default.\\r\\n    // It is recommended usage, and is required for compatibility with Direct2D.\\r\\n    UINT creationFlags = D3D11_CREATE_DEVICE_BGRA_SUPPORT;\\r\\n\\r\\n#if defined(_DEBUG)\\r\\n    // If the project is in a debug build, enable debugging via SDK Layers with this flag.\\r\\n    creationFlags |= D3D11_CREATE_DEVICE_DEBUG;\\r\\n#endif\\r\\n\\r\\n    // This array defines the set of DirectX hardware feature levels this app will support.\\r\\n    // Note the ordering should be preserved.\\r\\n    // Don't forget to declare your application's minimum required feature level in its\\r\\n    // description.  All applications are assumed to support 9.1 unless otherwise stated.\\r\\n    D3D_FEATURE_LEVEL featureLevels[] = \\r\\n    {\\r\\n        D3D_FEATURE_LEVEL_11_1,\\r\\n        D3D_FEATURE_LEVEL_11_0,\\r\\n        D3D_FEATURE_LEVEL_10_1,\\r\\n        D3D_FEATURE_LEVEL_10_0,\\r\\n        D3D_FEATURE_LEVEL_9_3,\\r\\n        D3D_FEATURE_LEVEL_9_2,\\r\\n        D3D_FEATURE_LEVEL_9_1\\r\\n    };\\r\\n\\r\\n    // Create the DX11 API device object, and get a corresponding context.\\r\\n    ComPtr<ID3D11Device> device;\\r\\n    ComPtr<ID3D11DeviceContext> context;\\r\\n    DX::ThrowIfFailed(\\r\\n        D3D11CreateDevice(\\r\\n            nullptr,                    // specify null to use the default adapter\\r\\n            D3D_DRIVER_TYPE_HARDWARE,\\r\\n            nullptr,                    // leave as nullptr unless software device\\r\\n            creationFlags,              // optionally set debug and Direct2D compatibility flags\\r\\n            featureLevels,              // list of feature levels this app can support\\r\\n            ARRAYSIZE(featureLevels),   // number of entries in above list\\r\\n            D3D11_SDK_VERSION,          // always set this to D3D11_SDK_VERSION\\r\\n            &device,                    // returns the Direct3D device created\\r\\n            &m_featureLevel,            // returns feature level of device created\\r\\n            &context                    // returns the device immediate context\\r\\n            )\\r\\n        );\\r\\n\\r\\n    // Get the DirectX11.1 device by QI off the DirectX11 one.\\r\\n    DX::ThrowIfFailed(\\r\\n        device.As(&m_d3dDevice)\\r\\n        );\\r\\n\\r\\n    // And get the corresponding device context in the same way.\\r\\n    DX::ThrowIfFailed(\\r\\n        context.As(&m_d3dContext)\\r\\n        );\\r\\n}\\r\\n\\r\\n// Allocate all memory resources that change on a window SizeChanged event.\\r\\nvoid Direct3DBase::CreateWindowSizeDependentResources()\\r\\n{ \\r\\n    // Store the window bounds so the next time we get a SizeChanged event we can\\r\\n    // avoid rebuilding everything if the size is identical.\\r\\n    m_windowBounds = m_window->Bounds;\\r\\n\\r\\n    // If the swap chain already exists, resize it.\\r\\n    if(m_swapChain != nullptr)\\r\\n    {\\r\\n        DX::ThrowIfFailed(\\r\\n            m_swapChain->ResizeBuffers(2, 0, 0, DXGI_FORMAT_B8G8R8A8_UNORM, 0)\\r\\n            );\\r\\n    }\\r\\n    // Otherwise, create a new one.\\r\\n    else\\r\\n    {\\r\\n        // Create a descriptor for the swap chain.\\r\\n        DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {0};\\r\\n        swapChainDesc.Width = 0;                                     // use automatic sizing\\r\\n        swapChainDesc.Height = 0;\\r\\n        swapChainDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;           // this is the most common swapchain format\\r\\n        swapChainDesc.Stereo = false; \\r\\n        swapChainDesc.SampleDesc.Count = 1;                          // don't use multi-sampling\\r\\n        swapChainDesc.SampleDesc.Quality = 0;\\r\\n        swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\\r\\n        swapChainDesc.BufferCount = 2;                               // use two buffers to enable flip effect\\r\\n        swapChainDesc.Scaling = DXGI_SCALING_NONE;\\r\\n        swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL; // we recommend using this swap effect for all applications\\r\\n        swapChainDesc.Flags = 0;\\r\\n\\r\\n        // Once the desired swap chain description is configured, it must be created on the same adapter as our D3D Device\\r\\n\\r\\n        // First, retrieve the underlying DXGI Device from the D3D Device\\r\\n        ComPtr<IDXGIDevice1>  dxgiDevice;\\r\\n        DX::ThrowIfFailed(\\r\\n            m_d3dDevice.As(&dxgiDevice)\\r\\n            );\\r\\n\\r\\n        // Identify the physical adapter (GPU or card) this device is running on.\\r\\n        ComPtr<IDXGIAdapter> dxgiAdapter;\\r\\n        DX::ThrowIfFailed(\\r\\n            dxgiDevice->GetAdapter(&dxgiAdapter)\\r\\n            );\\r\\n\\r\\n        // And obtain the factory object that created it.\\r\\n        ComPtr<IDXGIFactory2> dxgiFactory;\\r\\n        DX::ThrowIfFailed(\\r\\n            dxgiAdapter->GetParent(\\r\\n                __uuidof(IDXGIFactory2), \\r\\n                &dxgiFactory\\r\\n                )\\r\\n            );\\r\\n\\r\\n\\t\\tWindows::UI::Core::CoreWindow^ p = m_window.Get();\\r\\n\\r\\n        // Create a swap chain for this window from the DXGI factory.\\r\\n        DX::ThrowIfFailed(\\r\\n            dxgiFactory->CreateSwapChainForCoreWindow(\\r\\n                m_d3dDevice.Get(),\\r\\n                reinterpret_cast<IUnknown*>(p),\\r\\n                &swapChainDesc,\\r\\n                nullptr,    // allow on all displays\\r\\n                &m_swapChain\\r\\n                )\\r\\n            );\\r\\n            \\r\\n        // Ensure that DXGI does not queue more than one frame at a time. This both reduces \\r\\n        // latency and ensures that the application will only render after each VSync, minimizing \\r\\n        // power consumption.\\r\\n        DX::ThrowIfFailed(\\r\\n            dxgiDevice->SetMaximumFrameLatency(1)\\r\\n            );\\r\\n    }\\r\\n    \\r\\n    // Obtain the backbuffer for this window which will be the final 3D rendertarget.\\r\\n    ComPtr<ID3D11Texture2D> backBuffer;\\r\\n    DX::ThrowIfFailed(\\r\\n        m_swapChain->GetBuffer(\\r\\n            0,\\r\\n            __uuidof(ID3D11Texture2D),\\r\\n            &backBuffer\\r\\n            )\\r\\n        );\\r\\n\\r\\n    // Create a view interface on the rendertarget to use on bind.\\r\\n    DX::ThrowIfFailed(\\r\\n        m_d3dDevice->CreateRenderTargetView(\\r\\n            backBuffer.Get(),\\r\\n            nullptr,\\r\\n            &m_renderTargetView\\r\\n            )\\r\\n        );\\r\\n\\r\\n    // Cache the rendertarget dimensions in our helper class for convenient use.\\r\\n    D3D11_TEXTURE2D_DESC backBufferDesc;\\r\\n    backBuffer->GetDesc(&backBufferDesc);\\r\\n    m_renderTargetSize.Width  = static_cast<float>(backBufferDesc.Width);\\r\\n    m_renderTargetSize.Height = static_cast<float>(backBufferDesc.Height);\\r\\n\\r\\n    // Create a descriptor for the depth/stencil buffer.\\r\\n    CD3D11_TEXTURE2D_DESC depthStencilDesc(\\r\\n        DXGI_FORMAT_D24_UNORM_S8_UINT, \\r\\n        backBufferDesc.Width,\\r\\n        backBufferDesc.Height,\\r\\n        1,\\r\\n        1,\\r\\n        D3D11_BIND_DEPTH_STENCIL);\\r\\n\\r\\n    // Allocate a 2-D surface as the depth/stencil buffer.\\r\\n    ComPtr<ID3D11Texture2D> depthStencil;\\r\\n    DX::ThrowIfFailed(\\r\\n        m_d3dDevice->CreateTexture2D(\\r\\n            &depthStencilDesc,\\r\\n            nullptr,\\r\\n            &depthStencil\\r\\n            )\\r\\n        );\\r\\n\\r\\n    // Create a DepthStencil view on this surface to use on bind.\\r\\n    DX::ThrowIfFailed(\\r\\n        m_d3dDevice->CreateDepthStencilView(\\r\\n            depthStencil.Get(),\\r\\n            &CD3D11_DEPTH_STENCIL_VIEW_DESC(D3D11_DSV_DIMENSION_TEXTURE2D),\\r\\n            &m_depthStencilView\\r\\n            )\\r\\n        );\\r\\n\\r\\n    // Create a viewport descriptor of the full window size.\\r\\n    CD3D11_VIEWPORT viewPort(\\r\\n        0.0f,\\r\\n        0.0f,\\r\\n        static_cast<float>(backBufferDesc.Width),\\r\\n        static_cast<float>(backBufferDesc.Height)\\r\\n        );\\r\\n        \\r\\n    // Set the current viewport using the descriptor.\\r\\n    m_d3dContext->RSSetViewports(1, &viewPort);\\r\\n}\\r\\n\\r\\nvoid Direct3DBase::UpdateForWindowSizeChange()\\r\\n{\\r\\n    if (m_window->Bounds.Width  != m_windowBounds.Width ||\\r\\n        m_window->Bounds.Height != m_windowBounds.Height)\\r\\n    {\\r\\n        m_renderTargetView = nullptr;\\r\\n        m_depthStencilView = nullptr;\\r\\n        CreateWindowSizeDependentResources();\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid Direct3DBase::Present()\\r\\n{\\r\\n    // The first argument instructs DXGI to block until VSync, putting the application\\r\\n    // to sleep until the next VSync. This ensures we don't waste any cycles rendering\\r\\n    // frames that will never be displayed to the screen.\\r\\n    HRESULT hr = m_swapChain->Present(1, 0);\\r\\n\\r\\n    // If the device was removed either by a disconnect or a driver upgrade, we \\r\\n    // must completely reinitialize the renderer.\\r\\n    if (hr == DXGI_ERROR_DEVICE_REMOVED || hr == DXGI_ERROR_DEVICE_RESET)\\r\\n    {\\r\\n        Initialize(m_window.Get());\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        DX::ThrowIfFailed(hr);\\r\\n    }\\r\\n}\\r\\n\";"],"names":[],"sourceRoot":""}