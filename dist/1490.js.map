{"version":3,"file":"1490.js","mappings":"8IAAA,mvE","sources":["file:///C:\\0-E\\Code Store\\monaco-editor\\website\\src\\website\\data\\home-samples\\sample.elixir.txt"],"sourcesContent":["export default \"# Elixir is a dynamic, functional language for building scalable\\r\\n# and maintainable applications. Learn more: https://elixir-lang.org\\r\\n\\r\\n\\\"Elixir\\\" |> String.graphemes() |> Enum.frequencies()\\r\\n#=> %{\\\"E\\\" => 1, \\\"i\\\" => 2, \\\"l\\\" => 1, \\\"r\\\" => 1, \\\"x\\\" => 1}\\r\\n\\r\\n\\r\\n### Scalability ###\\r\\n\\r\\n# All Elixir code runs inside lightweight threads of execution (called processes)\\r\\n# that are isolated and exchange information via messages:\\r\\n\\r\\ncurrent_process = self()\\r\\n\\r\\n# Spawn an Elixir process (not an operating system one!)\\r\\nspawn_link(fn ->\\r\\n  send(current_process, {:msg, \\\"hello world\\\"})\\r\\nend)\\r\\n\\r\\n# Block until the message is received\\r\\nreceive do\\r\\n  {:msg, contents} -> IO.puts(contents)\\r\\nend\\r\\n\\r\\n\\r\\n### Fault-tolerance ###\\r\\n\\r\\n# To cope with failures, Elixir provides supervisors which describe\\r\\n# how to restart parts of your system when things go awry, going back\\r\\n# to a known initial state that is guaranteed to work:\\r\\n\\r\\nchildren = [\\r\\n  TCP.Pool,\\r\\n  {TCP.Acceptor, port: 4040}\\r\\n]\\r\\n\\r\\nSupervisor.start_link(children, strategy: :one_for_one)\\r\\n\\r\\n\\r\\n### Functional programming ###\\r\\n\\r\\n# Functional programming promotes a coding style that helps\\r\\n# developers write code that is short, concise, and maintainable.\\r\\n# One prominent example is pattern matching:\\r\\n\\r\\n%User{name: name, age: age} = User.get(\\\"John Doe\\\")\\r\\nname #=> \\\"John Doe\\\"\\r\\n\\r\\n# When mixed with guards, pattern matching allows us to elegantly\\r\\n# match and assert specific conditions for some code to execute:\\r\\n\\r\\ndef drive(%User{age: age}) when age >= 16 do\\r\\n  # Code that drives a car\\r\\nend\\r\\n\\r\\ndrive(User.get(\\\"John Doe\\\"))\\r\\n#=> Fails if the user is under 16\\r\\n\\r\\n\\r\\n### Extensibility and DSLs ###\\r\\n\\r\\n# Elixir has been designed to be extensible, letting developers\\r\\n# naturally extend the language to particular domains,\\r\\n# in order to increase their productivity.\\r\\n\\r\\ndefmodule MathTest do\\r\\n  use ExUnit.Case, async: true\\r\\n\\r\\n  test \\\"can add two numbers\\\" do\\r\\n    assert 1 + 1 == 2\\r\\n  end\\r\\nend\\r\\n\\r\\n\\r\\n### Erlang compatible ###\\r\\n\\r\\n# An Elixir programmer can invoke any Erlang function with no runtime cost:\\r\\n\\r\\n:crypto.hash(:md5, \\\"Using crypto from Erlang OTP\\\")\\r\\n#=> <<192, 223, 75, 115, ...>>\\r\\n\";"],"names":[],"sourceRoot":""}