"use strict";(self.webpackChunkmy_application=self.webpackChunkmy_application||[]).push([[6040],{6040:(r,n,o)=>{o.r(n),o.d(n,{default:()=>t});const t="// A fragment shader which lights textured geometry with point lights.\r\n// Taken from the introduction of the WebGPU Shading Lnaguage Specification\r\n// https://w3.org/TR/WGSL\r\n\r\n// Lights from a storage buffer binding.\r\nstruct PointLight {\r\n  position : vec3f,\r\n  color : vec3f,\r\n}\r\n\r\nstruct LightStorage {\r\n  pointCount : u32,\r\n  point : array<PointLight>,\r\n}\r\n@group(0) @binding(0) var<storage> lights : LightStorage;\r\n\r\n// Texture and sampler.\r\n@group(1) @binding(0) var baseColorSampler : sampler;\r\n@group(1) @binding(1) var baseColorTexture : texture_2d<f32>;\r\n\r\n// Function arguments are values from from vertex shader.\r\n@fragment\r\nfn fragmentMain(@location(0) worldPos : vec3f,\r\n                @location(1) normal : vec3f,\r\n                @location(2) uv : vec2f) -> @location(0) vec4f {\r\n  // Sample the base color of the surface from a texture.\r\n  let baseColor = textureSample(baseColorTexture, baseColorSampler, uv);\r\n\r\n  let N = normalize(normal);\r\n  var surfaceColor = vec3f(0);\r\n\r\n  // Loop over the scene point lights.\r\n  for (var i = 0u; i < lights.pointCount; i++) {\r\n    let worldToLight = lights.point[i].position - worldPos;\r\n    let dist = length(worldToLight);\r\n    let dir = normalize(worldToLight);\r\n\r\n    // Determine the contribution of this light to the surface color.\r\n    let radiance = lights.point[i].color * (1 / pow(dist, 2));\r\n    let nDotL = max(dot(N, dir), 0);\r\n\r\n    // Accumulate light contribution to the surface color.\r\n    surfaceColor += baseColor.rgb * radiance * nDotL;\r\n  }\r\n\r\n  // Return the accumulated surface color.\r\n  return vec4(surfaceColor, baseColor.a);\r\n}\r\n"}}]);
//# sourceMappingURL=6040.js.map