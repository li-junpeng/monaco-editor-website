{"version":3,"file":"3251.js","mappings":"8IAAA,8iH","sources":["file:///C:\\0-E\\Code Store\\monaco-editor\\website\\src\\website\\data\\home-samples\\sample.scheme.txt"],"sourcesContent":["export default \";;; make-matrix creates a matrix (a vector of vectors).\\r\\n(define make-matrix\\r\\n  (lambda (rows columns)\\r\\n    (do ((m (make-vector rows))\\r\\n         (i 0 (+ i 1)))\\r\\n        ((= i rows) m)\\r\\n        (vector-set! m i (make-vector columns)))))\\r\\n\\r\\n;;; matrix? checks to see if its argument is a matrix.\\r\\n;;; It isn't foolproof, but it's generally good enough.\\r\\n(define matrix?\\r\\n  (lambda (x)\\r\\n    (and (vector? x)\\r\\n         (> (vector-length x) 0)\\r\\n         (vector? (vector-ref x 0)))))\\r\\n\\r\\n;; matrix-rows returns the number of rows in a matrix.\\r\\n(define matrix-rows\\r\\n   (lambda (x)\\r\\n      (vector-length x)))\\r\\n\\r\\n;; matrix-columns returns the number of columns in a matrix.\\r\\n(define matrix-columns\\r\\n   (lambda (x)\\r\\n      (vector-length (vector-ref x 0))))\\r\\n\\r\\n;;; matrix-ref returns the jth element of the ith row.\\r\\n(define matrix-ref\\r\\n  (lambda (m i j)\\r\\n    (vector-ref (vector-ref m i) j)))\\r\\n\\r\\n;;; matrix-set! changes the jth element of the ith row.\\r\\n(define matrix-set!\\r\\n  (lambda (m i j x)\\r\\n    (vector-set! (vector-ref m i) j x)))\\r\\n\\r\\n;;; mul is the generic matrix/scalar multiplication procedure\\r\\n(define mul\\r\\n  (lambda (x y)\\r\\n    ;; mat-sca-mul multiplies a matrix by a scalar.\\r\\n    (define mat-sca-mul\\r\\n       (lambda (m x)\\r\\n          (let* ((nr (matrix-rows m))\\r\\n                 (nc (matrix-columns m))\\r\\n                 (r  (make-matrix nr nc)))\\r\\n             (do ((i 0 (+ i 1)))\\r\\n                 ((= i nr) r)\\r\\n                 (do ((j 0 (+ j 1)))\\r\\n                     ((= j nc))\\r\\n                     (matrix-set! r i j\\r\\n                        (* x (matrix-ref m i j))))))))\\r\\n\\r\\n    ;; mat-mat-mul multiplies one matrix by another, after verifying\\r\\n    ;; that the first matrix has as many columns as the second\\r\\n    ;; matrix has rows.\\r\\n    (define mat-mat-mul\\r\\n       (lambda (m1 m2)\\r\\n          (let* ((nr1 (matrix-rows m1))\\r\\n                 (nr2 (matrix-rows m2))\\r\\n                 (nc2 (matrix-columns m2))\\r\\n                 (r   (make-matrix nr1 nc2)))\\r\\n             (if (not (= (matrix-columns m1) nr2))\\r\\n                 (match-error m1 m2))\\r\\n             (do ((i 0 (+ i 1)))\\r\\n                 ((= i nr1) r)\\r\\n                 (do ((j 0 (+ j 1)))\\r\\n                     ((= j nc2))\\r\\n                     (do ((k 0 (+ k 1))\\r\\n                          (a 0\\r\\n                             (+ a\\r\\n                                (* (matrix-ref m1 i k)\\r\\n                                   (matrix-ref m2 k j)))))\\r\\n                         ((= k nr2)\\r\\n                          (matrix-set! r i j a))))))))\\r\\n\\r\\n   ;; type-error is called to complain when mul receives an invalid\\r\\n   ;; type of argument.\\r\\n    (define type-error\\r\\n       (lambda (what)\\r\\n          (error 'mul\\r\\n             \\\"~s is not a number or matrix\\\"\\r\\n             what)))\\r\\n\\r\\n    ;; match-error is called to complain when mul receives a pair of\\r\\n    ;; incompatible arguments.\\r\\n    (define match-error\\r\\n       (lambda (what1 what2)\\r\\n          (error 'mul\\r\\n             \\\"~s and ~s are incompatible operands\\\"\\r\\n             what1\\r\\n             what2)))\\r\\n\\r\\n    ;; body of mul; dispatch based on input types\\r\\n    (cond\\r\\n      ((number? x)\\r\\n       (cond\\r\\n         ((number? y) (* x y))\\r\\n         ((matrix? y) (mat-sca-mul y x))\\r\\n         (else (type-error y))))\\r\\n      ((matrix? x)\\r\\n       (cond\\r\\n         ((number? y) (mat-sca-mul x y))\\r\\n         ((matrix? y) (mat-mat-mul x y))\\r\\n         (else (type-error y))))\\r\\n      (else (type-error x)))))\";"],"names":[],"sourceRoot":""}